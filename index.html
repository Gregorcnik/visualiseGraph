<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>Graph Visualisation</title>
	<link rel="icon" type="image/png" href="./favicon.png">
	<link rel="stylesheet" href="./style.css">
</head>

<body>
	<canvas id="graph"></canvas>
	<div id="logo-container">
		<a href="#"><img src="favicon.png" alt="logo" class="logo"></a>
		<pre class="logo-text">Developed by <strong>Gregor Potočnik</strong>     </pre>
	</div>
	<div id="menu">
		<h2>Upload</h2>

		<label>File type <a href="#help-formats" class="information"></a>
			<select id="fileType">
				<option value="auto" selected>Automatic detection</option>
				<option value="adj">Zero based adjacency (.adj)</option>
				<option value="adj1">One based adjacency (.adj)</option>
				<option value="g6">Graph6 (.g6)</option>
				<option value="s6">Sparse6 (.s6)</option>
			</select>
		</label>

		<label>Upload graph file
			<input id="fileInput" type="file" />
		</label>

		<button id="pasteBtn">Paste graph from clipboard</button>
		<hr>

		<button id="saveBtn">Save PNG</button>
		<hr>

		<h2>Commands</h2>
		<div class="button-row">
			<button id="shakeSmall">Shake a Bit</button>
			<button id="shakeBig">Shake a Lot</button>
		</div>
		<button id="toggleNum">Toggle Numbers</button>
		<hr>

		<h2>Simulation <a href="#help-parameters" class="information"></a></h2>
		<div class="slider" name="Length"><input id="len" type="range" min="50" max="200" step="1"></div>
		<div class="slider" name="Spring"><input id="spring" type="range" min="0.1" max="1" step="0.01"></div>
		<div class="slider" name="Electric"><input id="electric" type="range" min="10000" max="1000000" step="1000">
		</div>
		<div class="slider" name="Resistance coefficient"><input id="res" type="range" min="0.2" max="1" step="0.01">
		</div>
		<hr>

		<h2>Display</h2>
		<div class="slider" name="Radius"><input id="radius" type="range" min="1" max="40" step="1"></div>
		<div class="slider" name="Thickness"><input id="thick" type="range" min="1" max="20" step="1"></div>
		<hr>

		<h2 id="help-formats">Graph Formats</h2>

		<p><strong>Sparse6:</strong> A compact format for sparse graphs, used by <em>nauty</em> utilities. It is based
			on the adjacency list and always starts with a colon (<code>:</code>) to distinguish it from graph6.
			<a href="https://users.cecs.anu.edu.au/~bdm/data/formats.txt">More information.</a>
		</p>
		<p>Example (3d cube):
			<span class="code">:GaGsQQRQbR</span>
		</p>

		<p><strong>Graph6:</strong> A compact format for dense graphs, also used by <em>nauty</em>. It is based on the
			adjacency matrix.
			<a href="https://users.cecs.anu.edu.au/~bdm/data/formats.txt">More information.</a>
		</p>
		<p>Example (3d cube):
			<span class="code">Gs@ipo</span>
		</p>

		<p><strong>Adjacency List:</strong> Lists the neighbours of each vertex. The first line contains the neighbours
			of the first vertex, the second line for the second vertex, and so on. Neighbours can be separated by
			spaces, commas, or
			both. Lines may optionally begin with <code>vertex number:</code> for compatibility. Graphs can be written
			using 0-based or 1-based vertex numbering. The program will automatically detect the numbering by checking
			for the presence of zeroes in the file.</p>

		<p>Example (3d cube): <br>
		<div class="code" style="padding: 10px;">
			1: 8, 7, 4 <br>
			2: 8, 6, 7 <br>
			3: 8, 6, 4 <br>
			4: 3, 1, 5 <br>
			5: 4, 7, 6 <br>
			6: 3, 5, 2 <br>
			7: 1, 2, 5 <br>
			8: 1, 2, 3 <br>
		</div>
		</p>
		<hr>

		<h2 id="help-parameters">Simulation Parameters</h2>
		<p><strong>Length:</strong> Target edge length. Mainly affects the ratio between spring and electric forces.</p>
		<p><strong>Spring:</strong> Edge spring strength. Higher values give stronger edge influence.</p>
		<p><strong>Electric:</strong> Repulsion between vertices.</p>
		<p><strong>Resistance coefficient:</strong> Damps movement. Higher values reduce motion.</p>
		<p>Sliders don't support all possible values. You can set parameters manually via the browser's developer
			console, e.g. <span class="code">settings.resistanceCoefficient = 1.1;</span> (replace with any parameter
			and value).</p>

	</div>

	<script>
		/* --- canvas setup --- */
		const canvas = document.getElementById('graph');
		const ctx = canvas.getContext('2d');
		let CW, CH;
		function resize() {
			const menu = document.getElementById('menu');
			CW = canvas.width = window.innerWidth - menu.offsetWidth;
			CH = canvas.height = window.innerHeight;
		}
		window.addEventListener('resize', resize);
		resize();

		/* --- settings --- */
		const settings = {
			length: 100,
			spring: 0.3,
			electric: 1e5,
			resistanceCoefficient: 0.8,
			vertexRadius: 10,
			edgeThickness: 2,
			numbers: false
		};

		/* --- DOM -> settings binding --- */
		const bind = (id, key, f) => {
			const input = document.getElementById(id);
			if (!input) return;
			input.value = settings[key];

			const el = input.parentElement; // assuming .slider is the parent div
			const name = el.getAttribute('name');

			// Create label span
			const label = document.createElement('span');
			label.textContent = `${name}: ${input.value}`;
			label.style.display = 'block';
			label.style.marginBottom = '4px';
			label.className = 'slider-label';

			el.insertBefore(label, input);

			input.addEventListener('input', () => {
				settings[key] = f ? f(input.value) : +input.value;
				label.textContent = `${name}: ${input.value}`;
			});
		};

		bind('len', 'length');
		bind('spring', 'spring');
		bind('electric', 'electric');
		bind('res', 'resistance');
		bind('radius', 'vertexRadius');
		bind('thick', 'edgeThickness');


		/* --- graph data --- */
		let graph = [];  // adjacency list (0‑based)
		let vertices = [];

		function initVertices() {
			vertices = graph.map(() => ({
				x: Math.random() * 1000,
				y: Math.random() * 1000,
				vx: 0,
				vy: 0,
				m: 10
			}));
		}

		/* --- parsers --- */
		function parseAdj(text, zeroBased) {
			const lines = text.split(/\r?\n+/);

			return lines.map((raw, i) => {
				const idx = raw.indexOf(':');
				let rest = raw;
				if (idx !== -1) {
					rest = raw.slice(idx + 1);
				}
				rest = rest.trim();
				if (!rest) return [];

				// Replace commas with spaces, fold multiple spaces
				const tokens = rest.replace(/,/g, ' ').split(/\s+/);

				const neighbours = tokens.map(tok => {
					if (!/^\d+$/.test(tok))
						throw new Error(`Line ${i + 1} - non-numeric token "${tok}"`);
					const n = Number(tok);
					if (zeroBased) {
						return n;
					} else {
						return n - 1;
					}
				});

				return neighbours;
			});
		}

		function parseG6(text) {
			text = text.trim();
			if (text.startsWith('>>graph6<<')) text = text.slice(10);
			const vals = [...text].map(c => c.charCodeAt(0) - 63);
			let p = 0, n;
			if (vals[p] !== 63) { n = vals[p++]; }
			else if (vals[p + 1] !== 63) { n = (vals[p + 1] << 12) | (vals[p + 2] << 6) | vals[p + 3]; p += 4; }
			else { n = (vals[p + 2] << 30) | (vals[p + 3] << 24) | (vals[p + 4] << 18) | (vals[p + 5] << 12) | (vals[p + 6] << 6) | vals[p + 7]; p += 8; }
			const adj = Array.from({ length: n }, () => []);
			const data = vals.slice(p);
			let bit = 0;
			for (let j = 1; j < n; j++) {
				for (let i = 0; i < j; i++) {
					const byte = data[(bit / 6) | 0] ?? 0;
					const b = (byte >> (5 - (bit % 6))) & 1;
					if (b) { adj[i].push(j); adj[j].push(i); } bit++;
				}
			}
			return adj;
		}

		function parseS6(text) {
			text = text.trim();
			if (text.startsWith('>>sparse6<<')) text = text.slice(10);
			const line = (text.split(/\n/).find(l => l[0] === ':' || l[0] === ';') || '');
			if (!line || line[0] !== ':') throw 'not sparse6';
			const vals = [...line.slice(1)].map(c => c.charCodeAt(0) - 63);
			let p = 0, n;
			if (vals[p] !== 63) { n = vals[p++]; }
			else if (vals[p + 1] !== 63) { n = (vals[p + 1] << 12) | (vals[p + 2] << 6) | vals[p + 3]; p += 4; }
			else { n = (vals[p + 2] << 30) | (vals[p + 3] << 24) | (vals[p + 4] << 18) | (vals[p + 5] << 12) | (vals[p + 6] << 6) | vals[p + 7]; p += 8; }
			const adj = Array.from({ length: n }, () => []);
			const k = (n - 1).toString(2).length;
			let bits = '';
			for (let i = p; i < vals.length; i++) bits += vals[i].toString(2).padStart(6, '0');
			let idx = 0, v = 0;
			while (idx + 1 + k <= bits.length) {
				const b = bits[idx] === '1';
				const x = parseInt(bits.slice(idx + 1, idx + 1 + k), 2);
				idx += 1 + k;
				if (b) v++; if (x > v) v = x; else if (x < n && v < n) { adj[x].push(v); adj[v].push(x); }
			}
			return adj;
		}

		function loadGraph(text, type) {
			try {
				if (type === 'auto') {
					if (text.trim().includes('\n') || text.includes(',') || text.trim().includes(' ')) {
						const match = text.match(/^\s*(\d+)/);
						if (/\b0\b/.test(text)) type = 'adj';
						else type = 'adj1';
					} else if (text.trim()[0] == ':') {
						type = 's6';
					} else {
						type = 'g6';
					}
				}
				if (type === 'adj') graph = parseAdj(text, true);
				else if (type === 'adj1') graph = parseAdj(text, false);
				else if (type === 'g6') graph = parseG6(text);
				else if (type === 's6') graph = parseS6(text);
				else throw 'Unsupported type';
				initVertices();
			} catch (e) { alert('Parse error: ' + e); }
		}

		/* --- file input --- */
		const fileInput = document.getElementById('fileInput');
		const fileTypeSel = document.getElementById('fileType');

		fileInput.addEventListener('change', async e => {
			const file = e.target.files[0]; if (!file) return;
			const ext = file.name.split('.').pop().toLowerCase();
			const text = await file.text();
			const selType = fileTypeSel.value;
			const type = selType === 'auto' ? (ext === 'g6' || ext === 's6' ? ext : 'auto') : selType;
			loadGraph(text, type);
			main();
		});

		/* --- clipboard --- */
		document.getElementById('pasteBtn').addEventListener('click', async () => {
			try {
				const text = await navigator.clipboard.readText();
				if (!text) { alert('Clipboard empty'); return; }
				loadGraph(text, fileTypeSel.value);
				main();
			} catch (e) { alert('Clipboard access denied.'); }
		});

		/* --- physics helpers --- */
		const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

		function simulate() {
			if (dragging !== null) { vertices[dragging].vx = vertices[dragging].vy = 0; }
			const len = settings.length; const k = settings.spring; const q = settings.electric; const r = settings.resistanceCoefficient;
			for (let i = 0; i < graph.length; i++) {
				for (let j = i + 1; j < graph.length; j++) {
					const d = dist(vertices[i], vertices[j]) || 1;
					const spring = graph[i].includes(j) ? (d - len) * k : 0;
					const elec = q / d ** 2;
					const dx = (vertices[j].x - vertices[i].x) / d; const dy = (vertices[j].y - vertices[i].y) / d;
					const fx = -elec * dx + spring * dx;
					const fy = -elec * dy + spring * dy;
					vertices[i].vx += fx / vertices[i].m; vertices[i].vy += fy / vertices[i].m;
					vertices[j].vx -= fx / vertices[j].m; vertices[j].vy -= fy / vertices[j].m;
				}
			}
			vertices.forEach(v => { v.vx *= r; v.vy *= r; v.x += v.vx; v.y += v.vy; });
		}

		/* --- view state --- */
		const view = { cx: 0, cy: 0, scale: 1 };
		function worldToScreen(wx, wy) { return { x: (wx - view.cx) * view.scale + CW / 2, y: (wy - view.cy) * view.scale + CH / 2 }; }
		function screenToWorld(sx, sy) { return { x: (sx - CW / 2) / view.scale + view.cx, y: (sy - CH / 2) / view.scale + view.cy }; }

		/* --- dragging --- */
		let dragging = null; const dragOffset = { x: 0, y: 0 };
		canvas.addEventListener('mousedown', e => {
			if (!graph.length) return;
			const posW = screenToWorld(e.offsetX, e.offsetY);
			for (let i = 0; i < vertices.length; i++) {
				if (dist(vertices[i], posW) <= settings.vertexRadius / view.scale) {
					dragging = i; dragOffset.x = vertices[i].x - posW.x; dragOffset.y = vertices[i].y - posW.y; vertices[i].vx = vertices[i].vy = 0; break;
				}
			}
		});
		window.addEventListener('mousemove', e => {
			if (dragging === null) return; const rect = canvas.getBoundingClientRect(); const posW = screenToWorld(e.clientX - rect.left, e.clientY - rect.top); vertices[dragging].x = posW.x + dragOffset.x; vertices[dragging].y = posW.y + dragOffset.y;
		});
		window.addEventListener('mouseup', () => dragging = null);

		canvas.addEventListener('mousemove', e => {
			if (dragging !== null) return;
			if (!graph.length) { canvas.style.cursor = 'default'; return; }
			const posW = screenToWorld(e.offsetX, e.offsetY);
			const hit = vertices.some(v => dist(v, posW) <= settings.vertexRadius / view.scale);
			canvas.style.cursor = hit ? 'pointer' : 'default';
		});

		/* --- drawing --- */
		function drawGraph() {
			ctx.clearRect(0, 0, CW, CH);
			if (!graph.length) return;
			const xs = vertices.map(v => v.x), ys = vertices.map(v => v.y);
			const minx = Math.min(...xs), maxx = Math.max(...xs), miny = Math.min(...ys), maxy = Math.max(...ys);
			view.cx = (minx + maxx) / 2; view.cy = (miny + maxy) / 2; view.scale = Math.min((CW - 100) / (maxx - minx || 1), (CH - 100) / (maxy - miny || 1));
			ctx.lineWidth = settings.edgeThickness; ctx.strokeStyle = '#666';
			for (let i = 0; i < graph.length; i++) {
				for (const j of graph[i]) if (j > i) { const a = worldToScreen(vertices[i].x, vertices[i].y); const b = worldToScreen(vertices[j].x, vertices[j].y); ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke(); }
			}
			ctx.fillStyle = '#000'; ctx.font = (settings.vertexRadius + 2) + 'px system-ui';
			for (let i = 0; i < vertices.length; i++) {
				const s = worldToScreen(vertices[i].x, vertices[i].y);
				ctx.beginPath(); ctx.arc(s.x, s.y, settings.vertexRadius, 0, Math.PI * 2);
				ctx.fill();
				if (settings.numbers) {
					ctx.fillText(i, s.x + settings.vertexRadius + 2, s.y);
				}
			}
		}

		/* --- UI actions --- */
		document.getElementById('toggleNum').onclick = () => settings.numbers = !settings.numbers;
		const shake = f => vertices.forEach(v => { v.vx += (Math.random() - 0.5) * f; v.vy += (Math.random() - 0.5) * f; });
		document.getElementById('shakeBig').onclick = () => shake(200);
		document.getElementById('shakeSmall').onclick = () => shake(40);
		document.getElementById('saveBtn').onclick = () => { const link = document.createElement('a'); link.download = 'graph.png'; link.href = canvas.toDataURL('image/png'); link.click(); };

		/* --- main loop --- */
		let last = 0;
		const maxFPS = 50;
		const frameDelay = 1000 / maxFPS;

		let running = false;

		function main() {
			if (running) return;
			running = true;

			function loop(ts) {
				if (!running) return;

				if (ts - last >= frameDelay) {
					last = ts;
					simulate();
					drawGraph();
				}

				requestAnimationFrame(loop);
			}

			requestAnimationFrame(loop);
		}
	</script>
</body>

</html>